package main

import (
    "net/http"

    "github.com/gin-gonic/gin"
)


//-------------------Tables-------------------//
//----User----//
type user struct {
	ID        int8  `json:"id"`
	Username  string `json:"username"`
	Password  string `json:"password"`
	Firstname string `json:"firstname"`
	Lastname  string `json:"lastname"`
}
//---slice of User---//
var users = []user {
	{ID: 1, Username: "test@test.com", Password: "testPassword", Firstname: "testfn", Lastname: "testln"},
}

//-----Food Item------//
type foodItem struct {
	ID    int     `json:"id"`
	Name  string  `json:"name"`
	Price float32 `json:"price"`
}
//----Slice of Food Items----//
var foodItems = []foodItem {
	{ID: 1, Name: "Test Food Item", Price: 69.420},
}



//-------------checker functions---------------//
//-----authenticator----//
func Contains(sl []user, name user) bool {
	for _, value := range sl {
	   if value == name {
		  return true
	   }
	}
	return false
}
//-------id checker-----//
func Contains_id() bool {
	// if val, ok := users.ID; ok {
	 	return true
	// }
}



//-------------API functions-------------//
//-----login Response-------//
func getLoginResponse(c *gin.Context) {
	var newUser user

	if err := c.BindJSON(&newUser); err != nil {
		return
	}
	is_present := Contains(users, newUser)
	if is_present {
		c.IndentedJSON(http.StatusOK, gin.H{
			"Request" : "Success",
			"Status" : "200",
		}, nil)
	}
	
}

func getAllUsers(c *gin.Context) {
	c.IndentedJSON(http.StatusOK, users, nil)
}
//-----Add Users-------//
func postUsers(c *gin.Context) {
	var newUser user

	// Call BindJSON to bind the received JSON to
	// newUser.
	if err := c.BindJSON(&newUser); err != nil {
			return
	}

	// Add the new user to the slice.
	users = append(users, newUser)
	c.IndentedJSON(http.StatusCreated, newUser, nil)
}
//-------Get Items----------//
func getFoodItems(c *gin.Context) {
	id := c.Param("id")
	for i,v := range newItems {
		if v == id {
        fmt.Println("The slice contains", id, "at index", i)
        break
		}
	}
	//c.String(http.StatusOK, message)
}
//-------Post Items--------//
func getPostItems(c *gin.Context) {
	id := c.Param("id")
	var newItem foodItem
	var newItems []foodItem 
	copyNewItems := copy(newItems, foodItems)
	fmt.Println("New Table created for user ID: and %v elements added.", ,copyNewItems)
	if err := c.BindJSON(&newItem); err != nil {
		return
	}

	foodItems = append(newItems, newItem)
	c.IndentedJSON(http.StatusCreated, newItem, nil)
}


func main() {
    router := gin.Default()
    router.GET("/", func(c *gin.Context) {
        c.JSON(200, gin.H{
            "message": "Hello World!",
        })
    })
	//TODO: remove getAllUsers in the end
	user := router.Group("/users")
	{
		user.GET("/login", getLoginResponse)
		user.POST("/register", postUsers)
		user.GET("/users", getAllUsers)
	}

	item := router.Group("/users/:id/*action")
	{
		item.GET("/users/:id/", getFoodItems)
		func(c *gin.Context) {
			id := c.Param("id")
			action := c.Param("action")
			message := name + " is " + action
			c.String(http.StatusOK, message)
		}
	}

    router.Run() // listen and serve on 0.0.0.0:8080
}

/*TODO: 
1. Create a struct of items with food name and price and slice. (Done)
2. Figure out how to put integer in url for accessing items table of all users. 
3. Figure out how to check if ID in url/json exists in the map of items against the user of id, use GORM Library.
4. Figure out a way to append the slice of items for a user against their id. */
